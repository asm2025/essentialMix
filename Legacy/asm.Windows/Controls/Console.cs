using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using asm.Extensions;
using asm.Helpers;
using asm.IO;
using asm.Threading;
using asm.Windows.Design;
using JetBrains.Annotations;

namespace asm.Windows.Controls
{
	[Designer(typeof(EmptyStringControlDesigner))]
	public class Console : TextBox
	{
		private const string CAT_MODE = "Mode";
		private const string CAT_BEHAVIOUR = "Behaviour";

		private readonly IList<KeyMapping> _keyMappings = new List<KeyMapping>();

		private int _inputStart = -1;
		private int _skipStart;
		private ProcessInterface _processInterface;
		private BufferedWriter _writer;

		public Console()
		{
			InDesignMode = LicenseManager.UsageMode == LicenseUsageMode.Designtime;
			IsLoading = true;

			InitializeComponent();
			InitializeKeyMappings();
			
			_writer = new BufferedWriter(FlushBuffer);

			_processInterface = new ProcessInterface();
			_processInterface.Output += (_, args) => OnOutput(args);
			_processInterface.Error += (_, args) => OnError(args);
		}

		protected override void Dispose(bool disposing)
		{
			if (disposing)
			{
				_processInterface.Stop(false);
				ObjectHelper.Dispose(ref _processInterface);
				ObjectHelper.Dispose(ref _writer);
			}

			base.Dispose(disposing);
		}

		protected override void OnHandleCreated(EventArgs e)
		{
			base.OnHandleCreated(e);
			IsLoading = false;
		}

		/// <inheritdoc />
		protected override void OnHandleDestroyed(EventArgs e)
		{
			base.OnHandleDestroyed(e);
			FreeConsole();
		}

		protected override void OnPaintBackground(PaintEventArgs e)
		{
			if (InDesignMode)
			{
				e.Graphics.FillRectangle(SystemBrushes.ControlDark, e.ClipRectangle);
				return;
			}

			base.OnPaintBackground(e);
		}

		/// <inheritdoc />
		protected override void OnKeyDown(KeyEventArgs e)
		{
			if (ProcessedInput && HasInputProcess)
			{
				IEnumerable<KeyMapping> mappings = _keyMappings.Where(k => k == e);

				//  Go through each mapping, send the message.
				//foreach (var mapping in mappings)
				//{
				//SendKeysEx.SendKeys(CurrentProcessHwnd, mapping.SendKeysMapping);
				//inputWriter.WriteLine(mapping.StreamMapping);
				//WriteInput("\x3", Color.White, false);
				//}

				// If we handled a mapping, we're done here.
				if (mappings.Any())
				{
					e.SuppressKeyPress = true;
					return;
				}
			}

			// If we're at the input point and it's backspace, bail.
			if (SelectionStart <= _inputStart && e.KeyCode.IsBackspace())
			{
				e.SuppressKeyPress = true;
				return;
			}

			// Are we in the read-only zone?
			if (SelectionStart < _inputStart)
			{
				// Allow arrows and Ctrl-C.
				if (!e.KeyCode.IsFunction() 
					&& !e.KeyCode.IsNavigation() 
					&& !(e.KeyCode == Keys.C && e.Control))
				{
					e.SuppressKeyPress = true;
					return;
				}
			}

			//  Is it the return key?
			if (e.KeyCode.IsEnter())
			{
				//  Get the input.
				SelectionStart = TextLength;
				string input = Text.Substring(_inputStart, SelectionStart - _inputStart);
				//  Write the input (without echoing).
				WriteToProcess(input);
				e.SuppressKeyPress = true;
				return;
			}
			base.OnKeyDown(e);
		}

		public event EventHandler<string> Output;
		public event EventHandler<string> Error;
		public event EventHandler<(string Name, DateTime? ExitTime, int? ExitCode)> Exit;

		[Category(CAT_BEHAVIOUR)]
		public bool InputEnabled { get; set; } = true;

		[Category(CAT_BEHAVIOUR)]
		[Description(
			"Characters read by the ReadFile or ReadConsole function are written to the active screen buffer as they are read. This mode can be used only if the LineInput mode is also enabled.")]
		public bool EchoInput { get; set; } = true;

		[Category(CAT_BEHAVIOUR)]
		[Description(
			"The ReadFile or ReadConsole function returns only when a carriage return character is read. If this mode is disabled, the functions return when one or more characters are available.")]
		public bool LineInput { get; set; } = true;

		[Category(CAT_BEHAVIOUR)]
		[Description(
			"When enabled, text entered in a console window will be inserted at the current cursor location and all text following that location will not be overwritten. When disabled, all following text will be overwritten.")]
		public bool InsertMode { get; set; } = true;

		[Category(CAT_BEHAVIOUR)]
		[Description(
			"If the mouse pointer is within the borders of the console window and the window has the keyboard focus, mouse events generated by mouse movement and button presses are placed in the input buffer. These events are discarded by ReadFile or ReadConsole, even when this mode is enabled.")]
		public bool MouseInput { get; set; } = true;

		[Category(CAT_BEHAVIOUR)]
		[Description(
			"User interactions that change the size of the console screen buffer are reported in the console's input buffer. Information about these events can be read from the input buffer by applications using the ReadConsoleInput function, but not by those using ReadFile or ReadConsole.")]
		public bool WindowInput { get; set; }

		[Category(CAT_BEHAVIOUR)]
		[Description(
			"CTRL+C is processed by the system and is not placed in the input buffer. If the input buffer is being read by ReadFile or ReadConsole, other control keys are processed by the system and are not returned in the ReadFile or ReadConsole buffer. If the LineInput mode is also enabled, backspace, carriage return, and line feed characters are handled by the global::System.")]
		public bool ProcessedInput { get; set; }

		[Category(CAT_MODE)]
		[Description("This flag enables the user to use the mouse to select and edit text.")]
		public bool QuickEdit { get; set; } = true;

		[Browsable(false)]
		public int BufferSize
		{
			get => _writer.BufferSize;
			set => _writer.BufferSize = value;
		}

		[Browsable(false)]
		public ProcessInterface Interface => _processInterface;

		[Browsable(false)]
		public bool HasInputProcess => _processInterface.HasInputProcess;

		protected bool InDesignMode { get; }
		protected bool IsLoading { get; set; }
		protected bool ConsoleCreated { get; private set; }
		protected bool ConsoleAttached { get; private set; }

		public bool CaptureConsole()
		{
			if (InDesignMode || ConsoleAttached) return true;

			try
			{
				if (ConsoleHelper.AttachConsole(Handle, out bool consoleCreated, false))
				{
					ConsoleCreated = consoleCreated;
					ConsoleAttached = true;
					System.Console.InputEncoding = EncodingHelper.Default;
					System.Console.SetOut(_writer);
					System.Console.SetError(_writer);
					UpdateMode();
					return true;
				}
			}
			catch
			{
				FreeConsole();
			}

			return false;
		}

		public void FreeConsole()
		{
			if (InDesignMode || !ConsoleCreated) return;
			ConsoleHelper.FreeConsole();
			ConsoleCreated = ConsoleAttached = false;
		}

		public bool StartShell() { return StartShell(null); }

		public bool StartShell(RunSettingsBase settings) { return StartInputProcess("cmd.exe", null, settings); }

		public bool StartInputProcess([NotNull] string fileName) { return StartInputProcess(fileName, null, null); }

		public bool StartInputProcess([NotNull] string fileName, string arguments) { return StartInputProcess(fileName, arguments, null); }

		public bool StartInputProcess([NotNull] string fileName, RunSettingsBase settings) { return StartInputProcess(fileName, null, settings); }

		public bool StartInputProcess([NotNull] string fileName, string arguments, RunSettingsBase settings)
		{
			bool result = _processInterface.StartInputProcess(fileName, arguments, settings);
			if (!result) return false;
			this.InvokeIf(() =>
			{
				if (!InputEnabled) return;
				ReadOnly = false;
			});
			return true;
		}

		public void Stop() { Stop(true); }

		public void Stop(bool waitForProcess)
		{
			_processInterface.Stop(waitForProcess);
		}

		public bool WriteToProcess(string value)
		{
			if (!_processInterface.WriteInput(value)) return false;
			this.InvokeIf(() =>
			{
				_inputStart = SelectionStart + 1;
				_skipStart = value.Length;
			});
			return true;
		}

		public bool WriteInput(string value)
		{
			if (!WriteToProcess(value)) return false;
			_writer.Write(value);
			return true;
		}
		
		public void Write(char value) { _writer.Write(value); }

		public void Write(string value) { _writer.Write(value); }

		public void WriteLine(string value) { _writer.WriteLine(value); }

		public void WriteError(string value) { Write(value); }
		public void WriteErrorLine(string value) { WriteLine(value); }

		public new void Clear()
		{
			this.InvokeIf(() =>
			{
				_writer.Clear();
				base.Clear();
				_inputStart = 0;
				_skipStart = 0;
			});
		}

		public void UpdateMode()
		{
			ConsoleModesEnum add = ConsoleModesEnum.NONE;
			ConsoleModesEnum remove = ConsoleModesEnum.NONE;

			if (EchoInput) add |= ConsoleModesEnum.ENABLE_ECHO_INPUT;
			else remove |= ConsoleModesEnum.ENABLE_ECHO_INPUT;

			if (LineInput) add |= ConsoleModesEnum.ENABLE_LINE_INPUT;
			else remove |= ConsoleModesEnum.ENABLE_LINE_INPUT;

			if (InsertMode) add |= ConsoleModesEnum.ENABLE_INSERT_MODE;
			else remove |= ConsoleModesEnum.ENABLE_INSERT_MODE;

			if (MouseInput) add |= ConsoleModesEnum.ENABLE_MOUSE_INPUT;
			else remove |= ConsoleModesEnum.ENABLE_MOUSE_INPUT;

			if (WindowInput) add |= ConsoleModesEnum.ENABLE_WINDOW_INPUT;
			else remove |= ConsoleModesEnum.ENABLE_WINDOW_INPUT;

			if (ProcessedInput) add |= ConsoleModesEnum.ENABLE_PROCESSED_INPUT;
			else remove |= ConsoleModesEnum.ENABLE_PROCESSED_INPUT;

			if (QuickEdit) add |= ConsoleModesEnum.ENABLE_QUICK_EDIT_MODE;
			else remove |= ConsoleModesEnum.ENABLE_QUICK_EDIT_MODE;

			ConsoleHelper.SetMode(remove, add);
		}

		protected virtual void OnOutput(string e)
		{
			this.InvokeIf(() =>
			{
				if (_skipStart > 0)
				{
					if (e != null && e.Length >= _skipStart)
					{
						int n = Math.Min(_skipStart, e.Length);
						_skipStart -= n;
						e = e.Right(e.Length - n);
					}
				}

				Write(e);
				Output?.Invoke(this, e);
			});
		}

		protected virtual void OnError(string e)
		{
			this.InvokeIf(() =>
			{
				WriteError(e);
				Error?.Invoke(this, e);
			});
		}

		protected virtual void OnExit((string Name, DateTime? ExitTime, int? ExitCode) e)
		{
			this.InvokeIf(() =>
			{
				ReadOnly = true;
				Exit?.Invoke(this, e);
			});
		}

		protected void FlushBuffer(string value)
		{
			this.InvokeIf(() =>
			{
				AppendText(value);
				_inputStart = SelectionStart;
			});
		}

		private void InitializeComponent()
		{
			SuspendLayout();
			AcceptsTab = true;
			ReadOnly = true;
			Multiline = true;
			WordWrap = true;
			ScrollBars = ScrollBars.Vertical;
			Dock = DockStyle.Fill;
			HideSelection = false;
			Font = new Font("Consolas", 11F);
			ForeColor = System.Console.ForegroundColor.ToColor();
			BackColor = System.Console.BackgroundColor.ToColor();
			ResumeLayout(false);
		}

		private void InitializeKeyMappings()
		{
			//  Map 'tab'.
			_keyMappings.Add(new KeyMapping(Keys.Tab, "{TAB}", "\t"));

			//  Map 'Ctrl-C'.
			_keyMappings.Add(new KeyMapping(Keys.C, "^(c)", "\x03\r\n"));
		}
	}
}